% howto/howto.tex

\QuickQuizChapter{chp:How To Use This Book}{How To Use This Book}

이 책의 목적은 당신이 shared-memory parallel machine 을 정확성을 해치지
않으면서 프로그램하는 것을 돕는 것입니다.\footnote{또는, 좀 더 정확히는, 병렬성
없는 프로그래밍에 비해 정확성을 덜 해치면서요.} 우린 이 책의 디자인 원칙이
당신이 적어도 몇몇 병렬 프로그래밍의 함정들은 피하는데 도움을 주길 바랍니다.
즉, 당신은 이 책을 완성된 성당이라기보단 새로 건물을 지을 토대라고 생각해야
합니다.  이를 따르기로 한다면, 당신의 임무는 신나는 병렬 프로그래밍 세계에 진보
--- 결국엔 이 책을 구식으로 만들게 될 진보요 --- 를 가져오는것을 돕는겁니다.
병렬 프로그래밍은 사람들이 말하는 것처럼 어렵지 않습니다. 그리고 우리는 이 책이
당신의 병렬 프로그래밍 과제를 더 쉽고 재밌게 만들길 바랍니다.

%The purpose of this book is to help you program
%shared-memory parallel machines without risking your sanity.\footnote{
%	Or, perhaps more accurately, without much greater risk to your
%	sanity than that incurred by non-parallel programming.
%	Which, come to think of it, might not be saying all that much.}
%We hope that this book's design principles will help you avoid at least some
%parallel-programming pitfalls.
%That said, you should think of this book as a foundation on which to build,
%rather than as a completed cathedral.
%Your mission, if you choose to accept, is to help make further progress
%in the exciting field of parallel programming---progress that will
%in time render this book obsolete.
%Parallel programming is not as hard as some say, and we hope
%that this book makes your parallel-programming projects easier and
%more fun.

짧게 말해서, 병렬 프로그래밍을 과학, 연구, 뭔가 대단한 과제에 적용하려 하면,
그것은 곧바로 엔지니어링 문제가 되어버립니다.  따라서 우리는 특정 병렬
프로그래밍 작업들을 조사하고, 거기서 얻은 것들을 어떻게 다른 곳에도 적용할 수
있는지 이야기합니다.  그러한 적용은, 일부 케이스에서는 놀랍게도 자동화도
가능합니다.

%In short, where parallel programming once focused on science, research,
%and grand-challenge projects, it is quickly becoming an engineering
%discipline.
%We therefore examine specific parallel-programming tasks
%and describe how to approach them.
%In some surprisingly common cases, they can even be automated.

이 책은 성공적 병렬 프로그래밍 프로젝트에 숨어있는 엔지니어링 비법들을 알려주는
것이 새로운 세대의 병렬성 해커들을 느리고 고통스럽게 오래된 바퀴를 다시
만들어내는 대신, 그들의 에너지와 창의성을 새로운 개척자에게 집중하도록 도울 수
있길 바랍니다.
우린 진심으로 병렬 프로그래밍이 당신에게 최소한, 우리에게도 왔던 재미와 흥분,
그리고 도전을 당신에게 가져다 주길 바랍니다.

%This book is written in the hope that presenting the engineering
%discipline underlying successful
%parallel-programming projects will free a new generation of parallel hackers
%from the need to slowly and painstakingly reinvent old wheels, enabling
%them to instead focus their energy and creativity on new frontiers.
%We sincerely hope that parallel programming brings you at least as
%much fun, excitement, and challenge that it has brought to us!

\section{Roadmap}
\label{sec:howto:Roadmap}

이 책은 극소수의 영역에만 적용 가능한 최적의 알고리즘의 모음이라기보다는 폭넓게
적용될 수 있고 많이 사용된 디자인 테크닉들을 소개하는 안내서입니다.  당신은
지금 Chapter~\ref{chp:How To Use This Book}을 읽고 있습니다, 알고 있겠지만요.
Chapter~\ref{chp:Introduction} 은 병렬 프로그래밍에 대해 전반적으로 간단히
살펴봅니다.

%This book is a handbook of widely applicable and heavily
%used design techniques, rather than
%a collection of optimal algorithms with tiny areas of applicability.
%You are currently reading Chapter~\ref{chp:How To Use This Book}, but
%you knew that already.
%Chapter~\ref{chp:Introduction} gives a high-level overview of parallel
%programming.

Chapter~\ref{chp:Hardware and its Habits} 는 shared-memory parallel hardware 에
대해 소개합니다.  무엇보다도, 당신이 코드가 동작하게 될 하드웨어에 대해 모르면
좋은 병렬성 있는 코드를 작성하기가 어렵습니다. 하드웨어는 계속 발전할테니, 이
챕터는 항상 시대에 뒤쳐질겁니다.  따라서 우리는 내용을 최신으로 유지하기 위해
최선을 다할겁니다.  Chapter~\ref{chp:Tools of the Trade} 는 이어서
shared-memory 병렬 프로그래밍의 기본을 매우 간략히 소개합니다.

%Chapter~\ref{chp:Hardware and its Habits} introduces shared-memory
%parallel hardware.
%After all, it is difficult to write good parallel code unless you
%understand the underlying hardware.
%Because hardware constantly evolves, this chapter will always be
%out of date.
%We will nevertheless do our best to keep up.
%Chapter~\ref{chp:Tools of the Trade} then provides a very brief overview
%of common shared-memory parallel-programming primitives.

Chapter~\ref{chp:Counting} 에서는 가장 간단한 문제, 카운팅을 병렬화 하는 작업에
대해 자세히 알아봅니다.  대부분은 카운팅에 대해서는 잘 알고 있을테니, 이
챕터에서는 보다 흔한 컴퓨터 사이언스에서의 문제들에 정신을 뺏기지 않고 병렬
프로그래밍 이슈에 대해서만 집중할 수 있을 겁니다.  이 챕터는 병렬 프로그래밍
수업에서 가장 많이 활용되곤 합니다.

%Chapter~\ref{chp:Counting} takes an in-depth look at parallelizing
%one of the simplest problems imaginable, namely counting.
%Because almost everyone has an excellent grasp of counting, this chapter
%is able to delve into many important parallel-programming issues without
%the distractions of more-typical computer-science problems.
%My impression is that this chapter has seen the greatest use in
%parallel-programming coursework.

Chapter~\ref{cha:Partitioning and Synchronization Design} 에서는
Chapter~\ref{chp:Counting} 에서 알아본 문제들을 해결하는 설계 레벨의 방법들을
소개합니다.  가능할때엔 병렬성을 설계 레벨에서 해결하는 것이 중요합니다:
Dijkstra~\cite{Dijkstra:1968:LEG:362929.362947} 의 말을 바꿔쓰자면, ``개선된
병렬성은 최적이 아닌 것으로 본다''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.

%Chapter~\ref{cha:Partitioning and Synchronization Design}
%introduces a number of design-level methods of addressing the issues
%identified in Chapter~\ref{chp:Counting}.
%It turns out that it is important to address parallelism at
%the design level when feasible:
%To paraphrase Dijkstra~\cite{Dijkstra:1968:LEG:362929.362947},
%``retrofitted parallelism considered grossly
%suboptimal''~\cite{PaulEMcKenney2012HOTPARsuboptimal}.

이어지는 세개의 챕터는 세개의 중요한 동기화 방법을 각각 설명합니다.
Chapter~\ref{chp:Locking} 에서는 적어도 2014년에 와서는 제품 수준의 병렬
프로그래밍에 있어 가장 많이 사용되지도 않고, 일반적으로 병렬 프로그래밍의 가장
악랄한 악당으로 여겨지는 락킹에 대해 알아봅니다.  Chapter~\ref{chp:Data
Ownership} 는 과소평가되곤 하지만 실제로는 놀랍도록 여러 분야에 사용 가능하고
강력한 방법인 데이터 소유권에 대해 알아봅니다.  마지막으로
Chapter~\ref{chp:Data Structures} 에서는 레퍼런스 카운팅, 해저드 포인터, 순차적
락킹, 그리고 RCU 를 포함한 deferred-processing 메커니즘들을 소개합니다.

%The next three chapters examine three important approaches to
%synchronization.
%Chapter~\ref{chp:Locking} covers locking, which in 2014 is not only the
%workhorse of production-quality parallel programming, but is also widely
%considered to be parallel programming's worst villain.
%Chapter~\ref{chp:Data Ownership} gives a brief overview of data ownership,
%an often overlooked but remarkably pervasive and powerful approach.
%Finally, Chapter~\ref{chp:Deferred Processing} introduces a number of
%deferred-processing mechanisms, including reference counting,
%hazard pointers, sequence locking, and RCU.

챕터~\ref{chp:Data Structures} 에서는 앞에서 배운 내용들을 해시 테이블에 적용해
봅니다. 해시 테이블은 그 훌륭한 데이터 분리성으로 인해 널리 사용되고 있고,
때문에 (보통은) 훌륭한 성능과 확장성을 보입니다.

%Chapter~\ref{chp:Data Structures} applies the lessons of previous
%chapters to hash tables, which are heavily used due
%to their excellent partitionability, which (usually) leads to excellent
%performance and scalability.

많은 사람들이 비통해하듯이, validation (실증) 없이 이루어지는 병렬 프로그래밍은
비참한 실패로의 분명한 지름길입니다.
챕터~\ref{chp:Validation} 에서는 다양한 테스트 방법을 다룹니다.
물론 모든 부분에 대해 프로그램의 신뢰성을 테스트 하는 것은 불가능합니다.
따라서 챕터~\ref{chp:formal:Formal Verification} 에서는 몇개의 실용적인 형식
검증 (formal verification) 방법에 대해 간단히 다룹니다.

%As many have learned to their sorrow, parallel programming without
%validation is a sure path to abject failure.
%Chapter~\ref{chp:Validation} covers various forms of testing.
%It is of course impossible to test reliability into your program
%after the fact, so Chapter~\ref{chp:formal:Formal Verification}
%follows up with a brief overview of a couple of practical approaches to
%formal verification.

챕터~\ref{chp:Putting It All Together} 에서는 적당한 크기의 병렬 프로그래밍
문제들을 다룹니다.
이런 문제들의 어려움은 다양하지만 앞 챕터들의 내용을 이해한 사람에게는 적당할
겁니다.

%Chapter~\ref{chp:Putting It All Together}
%contains a series of moderate-sized parallel programming problems.
%The difficulty of these problems vary, but should be appropriate for
%someone who has mastered the material in the previous chapters.

챕터~\ref{sec:advsync:Advanced Synchronization} 에서는 메모리 배리어와
non-blocking 동기화를 포함한 고급 동기화 방법을 알아봅니다.
이어지는 챕터~\ref{chp:Ease of Use} 는 몇몇 ease-of-use 기법들을 이야기합니다.
마지막으로, 챕터~\ref{chp:Conflicting Visions of the Future} 에서는 공유 메모리
병렬 시스템 설계, 소프트웨어 / 하드웨어 트랜잭셔널 메모리, 그리고 병렬성을 위한
함수형 프로그래밍을 포함해 몇몇 가능할 법한 미래의 방향에 대해 알아봅니다.

%Chapter~\ref{sec:advsync:Advanced Synchronization}
%looks at advanced synchronization methods, including memory barriers
%and non-blocking synchronization.
%Chapter~\ref{chp:Ease of Use} follows up with some ease-of-use advice.
%Finally, Chapter~\ref{chp:Conflicting Visions of the Future}
%looks at a few possible future directions, including
%shared-memory parallel system design, software and hardware transactional
%memory, and functional programming for parallelism.

이 책의 끝에는 몇개의 부록이 있습니다.  그 중 가장 유명한 건 메모리 배리어에
대해 다루고 있는 Appendix~\ref{chp:app:whymb:Why Memory Barriers?} 일 겁니다.
Appendix~\ref{chp:Answers to Quick Quizzes} 는 다음 섹션에서 이야기할, 퀵
퀴즈들의 답을 담고 있습니다.

%This chapter is followed by a number of appendices.
%The most popular of these appears to be
%Appendix~\ref{chp:app:whymb:Why Memory Barriers?},
%which covers memory barriers.
%Appendix~\ref{chp:Answers to Quick Quizzes}
%contains the answers to the infamous Quick Quizzes, which are discussed in
%the next section.

\section{Quick Quizzes}
\label{sec:howto:Quick Quizzes}

``Quick quizzes'' 는 이 책 전반에 걸쳐 여기저기서 나오고, 그에 대한 답은
페이지~\pageref{chp:Answers to Quick Quizzes} 부터 시작하는
Appendix~\ref{chp:Answers to Quick Quizzes} 에서 볼 수 있습니다.
그 중 일부는 그 퀴즈가 제출된 곳의 내용에 기반하지만, 몇몇은 그 섹션 이외의
내용에 대해서도 생각해야 할 거고, 일부는 당신이 알고 있는 모든 내용을 필요로 할
수도 있습니다.
최대한 노력했다는 가정 하에, 당신이 이 책으로부터 얻을 수 있는 것은 당신이 배운
내용을 얼마나 실제로 응용하는지에 달려있습니다.  따라서, 답을 보기 전에 퀴즈를
풀기 위해 많은 노력을 기울인 독자는 향상된 병렬 프로그래밍에 대한 이해와 함께
그들의 노력이 결실로 돌아옴을 알 수 있을 것입니다.

%``Quick quizzes'' appear throughout this book, and the answers may
%be found in
%Appendix~\ref{chp:Answers to Quick Quizzes} starting on
%page~\pageref{chp:Answers to Quick Quizzes}.
%Some of them are based on material in which that quick quiz
%appears, but others require you to think beyond that section, and,
%in some cases, beyond the realm of current knowledge.
%As with most endeavors, what you get out of this book is largely
%determined by what you are willing to put into it.
%Therefore, readers who make a genuine effort to solve a quiz before
%looking at the answer
%find their effort repaid handsomely with increased understanding
%of parallel programming.

\QuickQuiz{}
	이 Quick Quiz 들의 답은 어디에 있을까요?

%	Where are the answers to the Quick Quizzes found?
\QuickQuizAnswer{
	페이지~\pageref{chp:Answers to Quick Quizzes} 에서 시작하는
	Appendix~\ref{chp:Answers to Quick Quizzes}.
%	In Appendix~\ref{chp:Answers to Quick Quizzes} starting on
%	page~\pageref{chp:Answers to Quick Quizzes}.

	쉽죠?
%	Hey, I thought I owed you an easy one!
} \QuickQuizEnd

\QuickQuiz{}
	몇몇 퀴즈는 저자의 입장이 아니라 독자의 입장에서 쓰인 것 같은데요.
	그런 의도가 맞나요?

%	Some of the Quick Quiz questions seem to be from the viewpoint
%	of the reader rather than the author.
%	Is that really the intent?
\QuickQuizAnswer{
	실제로 그렇답니다!  많은 질문들은 Paul E. Mckenny 가 이 내용들을 다루는
	수업을 듣는 학생이었다면 질문했을 법한 것들입니다.  Paul 은 이 내용들을
	교수님으로부터가 아니라 병렬 하드웨어와 소프트웨어로부터 배웠다는
	내용도 짚어둬야 할 것 같네요.  Paul 의 경험에 의하면, 교수님들은 Watson
	같은 실제 병렬 시스템과는 달리 말로 이야기되는 문제에 대해 답을 주려
	하곤 합니다.  물론, 어떤 교수님들이나 병렬 시스템들이 이런 종류의
	문제들에 대해 가장 유용한 답을 주는지에 대해서는 많은 토론이
	가능하겠습니다만, 지금은 일단 실제 교수님들과 병렬 시스템들에 따라
	그들이 주는 답의 유용성이 다를 수 있다는 점만 동의하고 넘어갑시다.

%	Indeed it is!
%	Many are questions that Paul E. McKenney would probably have
%	asked if he was a novice student in a class covering this material.
%	It is worth noting that Paul was taught most of this material by
%	parallel hardware and software, not by professors.
%	In Paul's experience, professors are much more likely to provide
%	answers to verbal questions than are parallel systems,
%	Watson notwithstanding.
%	Of course, we could have a lengthy debate over which of professors
%	or parallel systems provide the most useful answers to these sorts
%	of questions,
%	but for the time being let's just agree that usefulness of
%	answers varies widely across the population both of professors
%	and of parallel systems.

	그 외의 퀴즈들은 컨퍼런스 발표 중에, 그리고 이 책에서 다루는 내용을
	다루는 수업 중에 받은 실제 질문과 유사합니다.
	그리고 일부 퀴즈는 저자의 관점에서 쓰이기도 했습니다.

%	Other quizzes are quite similar to actual questions that have been
%	asked during conference presentations and lectures covering the
%	material in this book.
%	A few others are from the viewpoint of the author.
} \QuickQuizEnd

\QuickQuiz{}
	전 퀵 퀴즈를 좋아하지 않아요.
	어떡하죠?

%	These Quick Quizzes are just not my cup of tea.
%	What can I do about it?
\QuickQuizAnswer{

여기 몇가지 전략이 있습니다:

%Here are a few possible strategies:

\begin{enumerate}
\item	그냥 퀵 퀴즈를 무시하고 책을 읽으세요.  퀵 퀴즈의 흥미로운 내용들을
	놓치게 되겠지만 이 책의 퀵 퀴즈를 제외한 부분도 훌륭한 내용을 많이 담고
	있습니다.  만약 당신의 목표가 일반적인 내용에 대한 이해를 얻는 것이거나
	이 책을 통해 특정 문제에 대한 해결책을 찾는 것이라면 충분히 합리적인
	접근법입니다.

%\item	Just ignore the Quick Quizzes and read the rest of
%	the book.
%	You might miss out on the interesting material in
%	some of the Quick Quizzes, but the rest of the book
%	has lots of good material as well.
%	This is an eminently reasonable approach if your main
%	goal is to gain a general understanding of the material
%	or if you are skimming through to book to find a
%	solution to a specific problem.

\item	퀵 퀴즈가 집중을 방해하지만 무시하기엔 중요하다고 생각한다면, 언제든 이
	책의 소스를 git 저장소에서 클론할 수 있음을 기억하세요.
	그러고나서 \co{Makefile} 과 \co{qqz.sty} 를 수정해서 퀵 퀴즈가 PDF 에서
	사라지게 할 수 있습니다.
	또는, 해당 파일들을 수정해서 답변이 문제 바로 아래 나오도록 수정할 수도
	있습니다.

%\item	If you find the Quick Quizzes distracting but impossible
%	to ignore, you can always clone the \LaTeX{} source for
%	this book from the git archive.
%	You can then modify \co{Makefile} and \co{qqz.sty} to eliminate
%	the Quick Quizzes from the PDF output.
%	Alternatively, you could modify these two files so as
%	to pull the answers inline, immediately following
%	the questions.

\item	당신의 답을 구하느라 너무 많은 시간을 보내지 말고 곧바로 답을 보세요.
	현재 퀵 퀴즈의 답이 당신이 해결하려는 문제의 핵심을 쥐고 있는 게
	아니라면 이것도 합리적인 접근법입니다.  또한, 당신이 원하는게 해당
	내용에 대한 깊은 이해이지, 새로이 병렬성을 활용한 해결책을 맨바닥부터
	만들려 하는게 아닌 경우에도 이는 합리적인 접근법입니다.

%\item	Look at the answer immediately rather than investing
%	a large amount of time in coming up with your own
%	answer.
%	This approach is reasonable when a given Quick Quiz's
%	answer holds the key to a specific problem you are
%	trying to solve.
%	This approach is also reasonable if you want a somewhat
%	deeper understanding of the material, but when you do not
%	expect to be called upon to generate parallel solutions given
%	only a blank sheet of paper.
\end{enumerate}
} \QuickQuizEnd

간략히 정리하자면, 당신이 해당 내용에 대해 깊은 이해가 필요하다면, 어느 정도의
시간은 퀵 퀴즈의 답을 구하는데 사용할 필요가 있습니다.
가만히 내용을 읽기만 하는 것도 물론 의미있습니다만, 완벽한 문제 해결 능력을
갖는 것은 실질적인 문제를 풀어보는 것도 필요로 합니다.

%In short, if you need a deep
%understanding of the material, then you should invest some time
%into answering the Quick Quizzes.
%Don't get me wrong, passively reading the material can be quite
%valuable, but gaining full problem-solving capability really
%does require that you practice solving problems.

저는 이 깨달음을 저의 늦깎이 박사 과정에서 힘들게 얻었습니다.  저는 제게 익숙한
주제를 공부했는데, 제가 해당 챕터의 연습문제 중에 제가 곧바로 머리 속에서 답할
수 있는 내용이 얼마 안된다는 사실에 놀랐습니다.\footnote{ 아마 그래서 제
교수니들은 제가 그 수업을 포기하지 못하게 하셨다고 생각합니다} 저 스스로를 그
문제들을 풀도록 강제하는 것은 해당 내용에 대한 제 기억력을 매우 높였습니다.
따라서 저는 이 퀵 퀴즈들에 대해 제가 스스로 하지 않았던 것을 여러분에게
강요하고 있지는 않아요!

%I learned this the hard way during coursework for my late-in-life
%Ph.D.
%I was studying a familiar topic, and was surprised at how few of
%the chapter's exercises I could answer off the top of my head.\footnote{
%	So I suppose that it was just as well that my professors refused
%	to let me waive that class!}
%Forcing myself to answer the questions greatly increased my
%retention of the material.
%So with these Quick Quizzes I am not asking you to do anything
%that I have not been doing myself!

\section{Alternatives to This Book}
\label{sec:Alternatives to This Book}

Knuth 가 깨달았던 것과 같이, 당신의 책의 내용에 끝이 있으려면 그 책의 내용은
어딘가에 집중되어 있어야 합니다.  이 책은 운영체제 커널, 병렬 데이터 관리
시스템, 저수준 라이브러리 등과 같은 소프트웨어 스택의 바닥 쪽에 있는
소프트웨어를 주요 대상으로 두고 공유메모리 기반 병렬 프로그래밍에 중점을
둡니다.
이 책에서 프로그래밍 언어로는 C 언어를 사용합니다.

%As Knuth learned, if you want your book to be finite, it must be focused.
%This book focuses on shared-memory parallel programming, with an
%emphasis on software that lives near the bottom of the software stack,
%such as operating-system kernels, parallel data-management systems,
%low-level libraries, and the like.
%The programming language used by this book is C.

당신이 병렬성의 다른 분야에 관심있다면, 다른 책을 보는 편이 좋을 겁니다.
만약 그렇다면, 다행히도 여러 좋은 책들이 있습니다:

%If you are interested in other aspects of parallelism, you might well
%be better served by some other book.
%Fortunately, there are many alternatives available to you:

\begin{enumerate}
\item	보다 학술적이고 정밀하게 병렬 프로그래밍을 다루고 싶다면, Herlihy 와
	Shavit 의 책~\cite{HerlihyShavit2008Textbook}이 당신에게 적합할 겁니다.
	이 책은 추상화된 하드웨어에서 제공하는 원초적 기능들의 조합으로
	시작해서 락킹과 리스트, 큐, 해시 테이블, 그리고 카운터를 포함한 간단한
	자료구조들을 다루고, 마지막으로 트랜잭셔널 메모리를 다룹니다.  Michael
	Scott 의 책~\cite{MichaelScott2013Textbook} 은 비슷한 내용을 보다
	소프트웨어 엔지니어링에 중점을 두어서 접근합니다. 그리고, 제가 알기로는
	최초로 RCU 에 대한 내용의 섹션을 담은 채로 정식으로 학계에 출간된
	최초의 책입니다.

%\item	If you prefer a more academic and rigorous treatment of
%	parallel programming,
%	you might like Herlihy's and Shavit's
%	textbook~\cite{HerlihyShavit2008Textbook}.
%	This book starts with an interesting combination
%	of low-level primitives at high levels of abstraction
%	from the hardware, and works its way through locking
%	and simple data structures including lists, queues,
%	hash tables, and counters, culminating with transactional
%	memory.
%	Michael Scott's textbook~\cite{MichaelScott2013Textbook}
%	approaches similar material with more of a
%	software-engineering focus, and, as far as I know, is
%	the first formally published academic textbook to include a
%	section devoted to RCU.

\item	당신이 프로그래밍 언어적 실용성 관점에서의 병렬 프로그래밍에 대한
	학술적 처리를 알고 싶다면 Scott 의 책~\cite{MichaelScott2006Textbook}
	의 concurrency (동시성) 챕터를 재밌게 볼 수 있을 겁니다.

%\item	If you would like an academic treatment of parallel
%	programming from a programming-language-pragmatics viewpoint,
%	you might be interested in the concurrency chapter from Scott's
%	textbook~\cite{MichaelScott2006Textbook}
%	on programming-language pragmatics.

\item	객체 지향 패턴 전문가들이 병렬 프로그래밍을 어떻게 취급하는지 C++
	위주로 알고 싶다면 Schmidt 의 POSA
	시리즈~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
	BuschmannHenneySchmidt2007v4Textbook} 의 Volume~2 와 4 를 읽어봐도 좋을
	겁니다.  특히 Volume 4 는 그 작업물을 도매점 어플리케이션에 적용해본
	내용에 대한 재미있는 챕터들이 있습니다.  이 예제가 얼마나 실제 상황에
	가까운지는 병렬성에 내재된 문제들은 종종 실제 세계의 응용사례에서
	시작된다는 이야기를 하는 ``Partitioning the Big Ball of Mud'' 라는
	제목의 섹션에서 증명되었습니다.

%\item	If you are interested in an object-oriented patternist
%	treatment of parallel programming focussing on C++,
%	you might try Volumes~2 and 4 of Schmidt's POSA
%	series~\cite{SchmidtStalRohnertBuschmann2000v2Textbook,
%	BuschmannHenneySchmidt2007v4Textbook}.
%	Volume 4 in particular has some interesting chapters
%	applying this work to a warehouse application.
%	The realism of this example is attested to by
%	the section entitled ``Partitioning the Big Ball of Mud'',
%	wherein the problems inherent in parallelism often
%	take a back seat to the problems inherent in getting
%	one's head around a real-world application.

\item	당신이 리눅스 커널 디바이스 드라이버를 다루고 싶다면 Corbet, Rubini,
	그리고 Kroah-Hartman 이 쓴 ``Linux Device
	Drivers''~\cite{CorbetRubiniKroahHartman}, 그리고 Linux Weekly New
	웹사이트 (\url{http://lwn.net/} 를 반드시 봐야 합니다.
	리눅스 커널 내부에 대한 일반적 내용에 대해서는 많은 책과 자료들이
	있습니다.

%\item	If you want to work with Linux-kernel device drivers,
%	then Corbet's, Rubini's, and Kroah-Hartman's
%	``Linux Device Drivers''~\cite{CorbetRubiniKroahHartman}
%	is indespensible, as is the Linux Weekly News web site
%	(\url{http://lwn.net/}.
%	There is a large number of books and resources on
%	the more general topic of Linux kernel internals.

\item	당신의 주요 관심사가 과학 / 기술 분야 컴퓨팅이라면, 그리고 패턴주의자의
	접근방법을 선호한다면, Mattson 의 책~\cite{Mattson2005Textbook} 을 읽어
	보십시오.
	그 책에서는 Java, C/C++, OpenMP, 그리고 MPI 를 다룹니다.
	거기서 이야기하는 패턴들은 첫째로 설계, 다음으로 구현에 매우 집중되어
	있습니다.

%\item	If your primary focus is scientific and technical computing,
%	and you prefer a patternist approach,
%	you might try Mattson et al.'s
%	textbook~\cite{Mattson2005Textbook}.
%	It covers Java, C/C++, OpenMP, and MPI.
%	Its patterns are admirably focused first on design,
%	then on implementation.

\item	당신의 주요 관심사가 과학 / 기술 분야 컴퓨팅이고 GPU, CUDA, 그리고 MPI
	에 관심이 있다면, Norm Matloff 의 `Programming on Parallel
	Machines''~\cite{NormMatloff2013ParProcBook} 을 한번쯤 보세요.

%\item	If your primary focus is scientific and technical computing,
%	and you are interested in GPUs, CUDA, and MPI, you
%	might check out Norm Matloff's ``Programming on
%	Parallel Machines''~\cite{NormMatloff2013ParProcBook}.

\item	POSIX 쓰레드에 관심 있다면, David R.~Butenhof 의
	책~\cite{Butenhof1997pthreads} 을 읽어보세요.  또한, W.~Richard Stevens
	의 책~\cite{WRichardStevens1992} 은 UNIX 와 POSIX 를 다루고, Stewart
	Weiss 의 수업노트~\cite{StewartWeiss2013UNIX} 는 좋은 예제들과 함께
	완전하고 접근 가능한 소개를 제공합니다.

%\item	If you are interested in POSIX Threads, you might take
%	a look at David R.~Butenhof's book~\cite{Butenhof1997pthreads}.
%	In addition,
%	W.~Richard Stevens's book~\cite{WRichardStevens1992}
%	covers UNIX and POSIX, and Stewart Weiss's lecture
%	notes~\cite{StewartWeiss2013UNIX} provide an
%	thorough and accessible introduction with a good set of
%	examples.

\item	C++11 에 관심 있다면, Anthony Williams 의 ``C++ Concurrency in Action:
	Practical Multithreading''~\cite{AnthonyWilliams2012} 를 좋아할 수 있을
	겁니다.

%\item	If you are interested in C++11, you might like
%	Anthony Williams's ``C++ Concurrency in Action: Practical
%	Multithreading''~\cite{AnthonyWilliams2012}.

\item	C++ 에 관심 있지만 Windows 환경에 있다면 Dr. Dobb 의 잡지~\cite{HerbSutter2008EffectiveConcurrency} 에 실린 Herb Sutter 의 ``Effective Concurrency'' 시리즈를 읽어보세요.
	이 시리즈는 병렬성에의 일반적 접근을 잘 소개합니다.

%\item	If you are interested in C++, but in a Windows environment,
%	you might try Herb Sutter's ``Effective Concurrency''
%	series in
%	Dr. Dobbs Journal~\cite{HerbSutter2008EffectiveConcurrency}.
%	This series does a reasonable job of presenting a
%	commonsense approach to parallelism.

\item	Intel Threading Building Blocks 를 사용해 보고 싶다면, James Reinder 의
	책~\cite{Reinders2007Textbook} 이 아마 찾으시는 책일 겁니다.

%\item	If you want to try out Intel Threading Building Blocks,
%	then perhaps James Reinders's book~\cite{Reinders2007Textbook}
%	is what you are looking for.

\item	다양한 멀티 프로세서 시스템의 하드웨어 캐쉬 구성이 커널 내부 구현에
	어떤 영향을 끼치는지 궁금한 사람이라면 이
	연구~\cite{Schimmel:1994:USM:175689} 에 실린 Curt Schimmel 의 고전적
	접근을 한번 봐야 합니다.

%\item	Those interested in learning how various types of multi-processor
%	hardware
%	cache organizations affect the implementation of kernel
%	internals should take a look at Curt Schimmel's classic
%	treatment of this subject~\cite{Schimmel:1994:USM:175689}.

\item	마지막으로, Java 사용자라면 Doug Lea 의
	교재~\cite{DougLea1997Textbook,Goetz2007Textbook} 가 큰 도움이
	될겁니다.

%\item	Finally, those using Java might be well-served by Doug Lea's
%	textbooks~\cite{DougLea1997Textbook,Goetz2007Textbook}.

\end{enumerate}

하지만, 로우 레벨의, 특히 C 로 구현된 소프트웨어를 위한 병렬적 설계의 기본적
내용에 관심이 있다면, 이 책을 계속 읽으세요!

%However, if you are interested in principles of parallel design
%for low-level software, especially software written in C, read on!

\section{Sample Source Code}
\label{sec:howto:Sample Source Code}

This book discusses its fair share of source code, and in many cases
this source code may be found in the \co{CodeSamples} directory
of this book's git tree.
For example, on UNIX systems, you should be able to type the following:

\begin{quote}
	{\scriptsize
	\begin{verbatim}
		find CodeSamples -name rcu_rcpls.c -print
	\end{verbatim}
	}
\end{quote}

This command will locate the file \co{rcu_rcpls.c}, which is called out in
Section~\ref{sec:defer:``Toy'' RCU Implementations}.
Other types of systems have well-known ways of locating files by filename.

\section{Whose Book Is This?}
\label{sec:howto:Whose Book Is This?}

\begin{figure*}[tbp]
{
\scriptsize
\begin{verbatim}
  1 git clone git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git
  2 cd perfbook
  3 make
  4 evince perfbook.pdf & # Two-column version
  5 make perfbook-1c.pdf
  6 evince perfbook-1c.pdf & # One-column version for e-readers
\end{verbatim}
}
\caption{Creating an Up-To-Date PDF}
\label{fig:howto:Creating a Up-To-Date PDF}
\end{figure*}

\begin{figure*}[tbp]
{
\scriptsize
\begin{verbatim}
  1 git remote update
  2 git checkout origin/master
  3 make
  4 evince perfbook.pdf & # Two-column version
  5 make perfbook-1c.pdf
  6 evince perfbook-1c.pdf & # One-column version for e-readers
\end{verbatim}
}
\caption{Generating an Updated PDF}
\label{fig:howto:Generating an Updated PDF}
\end{figure*}

As the cover says, the editor is one Paul E.~McKenney.
However, the editor does accept contributions via the
\co{perfbook@vger.kernel.org} email list.
These contributions can be in pretty much any form, with popular
approaches including text emails,
patches against the book's \LaTeX{} source, and even \co{git pull} requests.
Use whatever form works best for you.

To create patches or \co{git pull} requests, you will need the
\LaTeX{} source to the book, which is at
\url{git://git.kernel.org/pub/scm/linux/kernel/git/paulmck/perfbook.git}.
You will of course also need \co{git} and \LaTeX{}, which are
available as part of most mainstream Linux distributions.
Other packages may be required, depending on the distribution you use.
The required list of packages for a few popular distributions is listed
in the file \co{FAQ.txt} in the \LaTeX{} source to the book.

To create and display a current \LaTeX{} source tree of this book,
use the list of Linux commands shown in
Figure~\ref{fig:howto:Creating a Up-To-Date PDF}.
In some environments, the \co{evince} command that displays \co{perfbook.pdf}
may need to be replaced, for example, with \co{acroread}.
The \co{git clone} command need only be used the first time you
create a PDF, subsequently, you can run the commands shown in
Figure~\ref{fig:howto:Generating an Updated PDF} to pull in any updates
and generate an updated PDF.
The commands in
Figure~\ref{fig:howto:Generating an Updated PDF}
must be run within the \co{perfbook} directory created by the commands
shown in
Figure~\ref{fig:howto:Creating a Up-To-Date PDF}.

PDFs of this book are sporadically posted at
\url{http://kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html}
and at
\url{http://www.rdrop.com/users/paulmck/perfbook/}.

The actual process of contributing patches and sending \co{git pull}
requests is similar to that of the Linux kernel, which is documented
in the \co{Documentation/SubmittingPatches} file in the Linux source tree.
One important requirement is that each patch (or commit, in the case
of a \co{git pull} request) must contain a valid \co{Signed-off-by:} line,
which has the following format:

\begin{quote}
	{ \scriptsize
	\co{Signed-off-by: My Name <myname@example.org>}
	}
\end{quote}

Please see \url{http://lkml.org/lkml/2007/1/15/219} for an example
patch containing a \co{Signed-off-by:} line.

It is important to note that the \co{Signed-off-by:} line has
a very specific meaning, namely that you are certifying that:

\begin{enumerate}
\item	The contribution was created in whole or in part
	by me and I have the right to submit it under
	the open source license indicated in the file; or
\item	The contribution is based upon previous work
	that, to the best of my knowledge, is covered
	under an appropriate open source License and I
	have the right under that license to submit that
	work with modifications, whether created in whole
	or in part by me, under the same open source
	license (unless I am permitted to submit under
	a different license), as indicated in the file; or
\item	The contribution was provided directly to me by
	some other person who certified (a), (b) or (c)
	and I have not modified it.
\item	The contribution is made free of any other party's
	intellectual property claims or rights.
\item	I understand and agree that this project and the
	contribution are public and that a record of the
	contribution (including all personal information
	I submit with it, including my sign-off) is
	maintained indefinitely and may be redistributed
	consistent with this project or the open source
	license(s) involved.
\end{enumerate}

This is similar to the Developer's Certificate of Origin (DCO) 1.1 used
by the Linux kernel.
The only addition is item~\#4.
This added item says that you wrote the contribution yourself, as opposed
to having (say) copied it from somewhere.
If multiple people authored a contribution, each should have a
\co{Signed-off-by:} line.

You must use your real name:  I unfortunately cannot accept pseudonymous or
anonymous contributions.

The language of this book is American English, however, the open-source
nature of this book permits translations, and I personally encourage them.
The open-source licenses covering this book additionally allow you
to sell your translation, if you wish.
I do request that you send me a copy of the translation (hardcopy if
available), but this is a request made as a professional courtesy,
and is not in any way a prerequisite to the permission that you already
have under the Creative Commons and GPL licenses.
Please see the \co{FAQ.txt} file in the source tree for a list of
translations currently in progress.
I consider a translation effort to be ``in progress'' once at least one
chapter has been fully translated.

As noted at the beginning of this section, I am this book's editor.
However, if you choose to contribute, it will be your book as well.
With that, I offer you Chapter~\ref{chp:Introduction}, our introduction.
